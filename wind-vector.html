---
layout: default
title: wind vector
description: 3d wind visualization
prototype: true
---
<style>
.preview {
    max-width: 1200px;
    min-height: 320px;
    padding: 0;
}

canvas {
  display: flex;
  flex-direction: column;
  width: 100%;
  flex: 1;
}

#mini-map-container {
  position: absolute;
  bottom: 20px;
  left: 20px;
  width: 200px;
  height: 200px;
  min-width: 150px;
  min-height: 150px;
  max-width: 400px;
  max-height: 400px;
  border: 4px solid white;
  border-radius: 8px;
  background: rgba(0, 0, 0, 0.8);
  z-index: 10;
  opacity: 0;
  transition: opacity 0.3s ease;
  box-shadow: 0 0 2rem 0 white;
  resize: both;
  overflow: hidden;
}

.mini-map-arrow {
  position: absolute;
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 16px solid #00ddff;
  transform-origin: center bottom;
  pointer-events: none;
  z-index: 15;
  filter: drop-shadow(0 0 4px rgba(0, 255, 255, 0.6));
  transition: transform 0.1s ease;
}

#mini-map-container.visible {
  opacity: 1;
}

#mini-map-canvas {
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: block;
}

#mini-map-resize-handle {
  position: absolute;
  top: 0;
  right: 0;
  width: 20px;
  height: 20px;
  background: linear-gradient(45deg, transparent 30%, white 30%, white 40%, transparent 40%, transparent 60%, white 60%, white 70%, transparent 70%);
  cursor: se-resize;
  pointer-events: auto;
  border-top-right-radius: 4px;
}

@media (max-width: 768px) {
  #mini-map-container {
    width: 150px;
    height: 150px;
    bottom: 15px;
    left: 15px;
    min-width: 120px;
    min-height: 120px;
    max-width: 300px;
    max-height: 300px;
  }
  
  #mini-map-resize-handle {
    width: 16px;
    height: 16px;
    }
}

#tooltip {
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 2px solid white;
  box-shadow: 0 0 20px white;
}
</style>

<canvas id="three-canvas"></canvas>
<div id="mini-map-container">
  <canvas id="mini-map-canvas"></canvas>
  <div id="mini-map-resize-handle"></div>
</div>

<!-- Hidden Leaflet map for texture generation -->
<div id="leaflet-map" style="width: 512px; height: 512px; position: absolute; top: -1000px; left: -1000px; visibility: hidden;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
// 3D Wind Vector Visualization
let scene, camera, renderer, controls;
let windCubes = [];
let windArrows = []; // Track wind direction arrows
let groundPlane;
let raycaster, mouse;
let isHovering = false; // Track hover state
let selectedFlightLevel = null; // Track selected flight level
let selectedCubes = []; // Track selected cube outlines
let arrowGeometry, arrowMaterial; // Reusable arrow geometry and material
let mouseDownPosition = { x: 0, y: 0 }; // Track mouse down position
let isDragging = false; // Track if user is dragging
let gui; // dat.GUI instance
let tooltip; // Tooltip element

// Mini map variables
let miniMapScene, miniMapCamera, miniMapRenderer;
let miniMapCanvas;
let miniMapContainer;
let miniMapGroundPlane;
let miniMapCubes = [];
let miniMapArrows = []; // HTML arrow elements for mini map

// Mini map resize variables
let isResizing = false;
let resizeStartSize = { width: 0, height: 0 };
let resizeStartMouse = { x: 0, y: 0 };

// Date and time control variables
let currentDate = new Date();
let currentTime = { hour: 14, minute: 0 }; // Default to 14:00 (2 PM)

// Leaflet map variables
let leafletMap;
let mapCanvas;
let mapContext;
let mapTexture;

// GUI settings
const settings = {
  region: 'Southeast',
  cubeOpacity: 0.03,
  mapStyle: 'OpenStreetMap',
  darkBackground: true, // true = black, false = white
  showWindArrows: true, // Show wind direction arrows by default
  currentDate: 'Oct 15, 2024',
  currentTime: '14:00',
  prevDate: function() { changeDate(-1); },
  nextDate: function() { changeDate(1); },
  prevTime: function() { changeTime(-1); },
  nextTime: function() { changeTime(1); },
  randomizeWind: function() {
    regenerateWindData();
    // Update mini map if a flight level is selected
    if (selectedFlightLevel !== null) {
      setTimeout(() => {
        updateMiniMap();
      }, 50); // Small delay to ensure cubes are fully generated
    }
  }
};

// Regional configurations with geographic bounds
const regions = {
  'Northeast': {
    bounds: [[39.0, -80.0], [45.0, -67.0]], // NY, NE, ME region
    center: [42.0, -73.5],
    zoom: 6,
    windPattern: 'nor_easter' // Nor'easter and Atlantic influence
  },
  'Southeast': {
    bounds: [[25.0, -87.0], [35.0, -75.0]], // FL, GA, SC, NC region
    center: [30.0, -81.0],
    zoom: 6,
    windPattern: 'gulf_stream' // Gulf Stream and tropical influence
  },
  'Midwest': {
    bounds: [[40.0, -93.0], [49.0, -80.0]], // Great Lakes region
    center: [44.5, -86.5],
    zoom: 6,
    windPattern: 'continental' // Continental and lake effect patterns
  },
  'Southwest': {
    bounds: [[31.0, -118.0], [37.0, -103.0]], // Desert Southwest
    center: [34.0, -110.5],
    zoom: 6,
    windPattern: 'desert' // Desert thermal and mountain wave patterns
  },
  'Northwest': {
    bounds: [[42.0, -125.0], [49.0, -110.0]], // Pacific Northwest
    center: [45.5, -117.5],
    zoom: 6,
    windPattern: 'pacific' // Pacific maritime influence
  },
  'Great Plains': {
    bounds: [[36.0, -105.0], [49.0, -90.0]], // Central Plains
    center: [42.5, -97.5],
    zoom: 6,
    windPattern: 'plains' // Prairie winds and storm systems
  }
};

// Date and time control functions
function formatDate(date) {
  const options = { month: 'short', day: 'numeric', year: 'numeric' };
  return date.toLocaleDateString('en-US', options);
}

function formatTime(timeObj) {
  const hour = timeObj.hour.toString().padStart(2, '0');
  const minute = timeObj.minute.toString().padStart(2, '0');
  return `${hour}:${minute}`;
}

function updateDateTimeDisplay() {
  settings.currentDate = formatDate(currentDate);
  settings.currentTime = formatTime(currentTime);
  
  // Update GUI display if available
  if (gui) {
    gui.updateDisplay();
  }
}

// Update background color
function updateBackgroundColor(isDark) {
  if (isDark) {
    scene.background = new THREE.Color(0x000000); // Black background
  } else {
    scene.background = new THREE.Color(0xffffff); // White background
  }
}

// Toggle wind arrows visibility
function toggleWindArrows(showArrows) {
  if (showArrows) {
    // Show arrows based on current selection/hover state
    if (selectedFlightLevel !== null) {
      // Show arrows for selected flight level
      windArrows.forEach(arrow => {
        arrow.visible = arrow.userData.yLevel === selectedFlightLevel;
      });
    } else {
      // Hide all arrows if no selection
      windArrows.forEach(arrow => {
        arrow.visible = false;
      });
    }
    
    // Show mini map arrows if mini map is visible
    if (selectedFlightLevel !== null) {
      miniMapArrows.forEach(arrow => {
        arrow.style.display = 'block';
      });
    }
  } else {
    // Hide all 3D arrows
    windArrows.forEach(arrow => {
      arrow.visible = false;
    });
    
    // Hide all mini map arrows
    miniMapArrows.forEach(arrow => {
      arrow.style.display = 'none';
    });
  }
}

function changeDate(days) {
  const newDate = new Date(currentDate);
  newDate.setDate(newDate.getDate() + days);
  currentDate = newDate;
  updateDateTimeDisplay();
  regenerateWindData(); // Update wind data when date changes
  
  // Update mini map if a flight level is selected
  if (selectedFlightLevel !== null) {
    updateMiniMap();
  }
}

function changeTime(hours) {
  currentTime.hour += hours;
  
  // Handle day rollover
  if (currentTime.hour >= 24) {
    currentTime.hour = 0;
    changeDate(1);
    return; // changeDate already calls updateDateTimeDisplay, regenerateWindData, and updateMiniMap
  } else if (currentTime.hour < 0) {
    currentTime.hour = 23;
    changeDate(-1);
    return; // changeDate already calls updateDateTimeDisplay, regenerateWindData, and updateMiniMap
  }
  
  updateDateTimeDisplay();
  regenerateWindData(); // Update wind data when time changes
  
  // Update mini map if a flight level is selected
  if (selectedFlightLevel !== null) {
    updateMiniMap();
  }
}



// Initialize the scene
function initScene() {
  // Scene setup
  scene = new THREE.Scene();
  // Set initial background based on settings
  updateBackgroundColor(settings.darkBackground); 

  // Get canvas and set up responsive sizing
  const canvas = document.getElementById('three-canvas');
  const rect = canvas.getBoundingClientRect();
  
  // Camera setup
  camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
  camera.position.set(15, 20, 15);
  
  // Renderer setup
  renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
  renderer.setSize(rect.width, rect.height);
  renderer.setPixelRatio(window.devicePixelRatio);

  // Basic lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Bright white ambient light
  scene.add(ambientLight);
  
  // Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.enablePan = false; // Disable panning

  // Raycaster for interactions
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  // Create ground plane
  createGroundPlane();
  
  // Create arrow geometry and material
  createArrowGeometry();
  
  // Generate wind cubes
  generateWindCubes();
  
  // Create flight level labels
  createFlightLevelLabels();
  
  // Create GUI
  createGUI();
  
  // Initialize date and time display
  updateDateTimeDisplay();
  
  // Create tooltip
  createTooltip();
  
  // Initialize mini map
  initMiniMap();
  
  // Add event listeners
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('click', onMouseClick);
  
  // Add touch event listeners for mobile support
  canvas.addEventListener('touchstart', onTouchStart, { passive: false });
  canvas.addEventListener('touchmove', onTouchMove, { passive: false });
  canvas.addEventListener('touchend', onTouchEnd, { passive: false });
  
  // Add mini map resize event listeners
  const resizeHandle = document.getElementById('mini-map-resize-handle');
  resizeHandle.addEventListener('mousedown', onMiniMapResizeStart);
  resizeHandle.addEventListener('touchstart', onMiniMapResizeStart, { passive: false });
  
  window.addEventListener('resize', onWindowResize);
  
  // Add failsafe to reset resize state if user switches away
  window.addEventListener('blur', function() {
    if (isResizing) {
      onMiniMapResizeEnd();
    }
  });
}

// Create dat.GUI interface
function createGUI() {
  gui = new dat.GUI();
  
  // Region selector
  gui.add(settings, 'region', Object.keys(regions)).name('US Region').onChange(function(value) {
    updateRegion(value);
  });
  
  // Map style selector
  gui.add(settings, 'mapStyle', ['OpenStreetMap', 'Satellite', 'Terrain']).name('Map Style').onChange(function(value) {
    updateMapStyle(value);
  });
  
  // Background color toggle
  gui.add(settings, 'darkBackground').name('Dark Background').onChange(function(value) {
    updateBackgroundColor(value);
  });
  
  // Wind arrows toggle
  gui.add(settings, 'showWindArrows').name('Show Wind Arrows').onChange(function(value) {
    toggleWindArrows(value);
  });
  
  // Date and time controls folder
  const timeFolder = gui.addFolder('Date & Time');
  
  // Add read-only date and time displays
  const dateController = timeFolder.add(settings, 'currentDate').name('Date').listen();
  const timeController = timeFolder.add(settings, 'currentTime').name('Time').listen();
  
  // Make the input fields read-only
  dateController.domElement.querySelector('input').readOnly = true;
  timeController.domElement.querySelector('input').readOnly = true;
  
  // Add navigation buttons
  timeFolder.add(settings, 'prevDate').name('← Previous Day');
  timeFolder.add(settings, 'nextDate').name('Next Day →');
  timeFolder.add(settings, 'prevTime').name('← Previous Hour');
  timeFolder.add(settings, 'nextTime').name('Next Hour →');
  timeFolder.open(); // Start with time folder open
  
  // Opacity control
  gui.add(settings, 'cubeOpacity', 0.01, 0.3).name('Cube Opacity').onChange(function(value) {
    updateCubeOpacity();
  });
  
  // Wind randomization button
  gui.add(settings, 'randomizeWind').name('Randomize Wind');
}

// Initialize Leaflet map
function initLeafletMap() {
  // Initialize Leaflet map (canvas already created in createGroundPlane)
  const mapDiv = document.getElementById('leaflet-map');
  leafletMap = L.map(mapDiv, {
    zoomControl: false,
    attributionControl: false,
    dragging: false,
    touchZoom: false,
    scrollWheelZoom: false,
    doubleClickZoom: false,
    boxZoom: false
  });
  
  // Add OpenStreetMap tiles
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19
  }).addTo(leafletMap);
  
  // Set initial region and load texture
  updateLeafletRegion(settings.region);
}

// Update Leaflet map to show different region
function updateLeafletRegion(regionName) {
  const region = regions[regionName];
  leafletMap.setView(region.center, region.zoom);
  
  // Immediately capture texture (no need to wait for hidden map)
  captureMapToTexture();
}

// Update map style
function updateMapStyle(styleName) {
  // Remove existing tile layers
  leafletMap.eachLayer(function(layer) {
    if (layer instanceof L.TileLayer) {
      leafletMap.removeLayer(layer);
    }
  });
  
  // Add new tile layer based on style
  let tileLayer;
  switch(styleName) {
    case 'OpenStreetMap':
      tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');
      break;
    case 'Satellite':
      tileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}');
      break;
    case 'Terrain':
      tileLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png');
      break;
    default:
      tileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png');
  }
  
  tileLayer.addTo(leafletMap);
  
  // Update texture after style change
  captureMapToTexture();
}

// Capture Leaflet map to canvas and create Three.js texture
function captureMapToTexture() {
  const region = regions[settings.region];
  const zoom = region.zoom;
  const center = region.center;
  
  // Calculate tile coordinates for the current region
  const lat = center[0];
  const lng = center[1];
  
  // Convert lat/lng to tile coordinates
  const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
  const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
  
  // Get current map style
  let tileUrl;
  switch(settings.mapStyle) {
    case 'OpenStreetMap':
      tileUrl = `https://tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
      break;
    case 'Satellite':
      tileUrl = `https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/${zoom}/${y}/${x}`;
      break;
    case 'Terrain':
      tileUrl = `https://tile.opentopomap.org/${zoom}/${x}/${y}.png`;
      break;
    default:
      tileUrl = `https://tile.openstreetmap.org/${zoom}/${x}/${y}.png`;
  }
  
  // Load the tile image
  const img = new Image();
  img.crossOrigin = 'anonymous';
  
  img.onload = function() {
    // Clear canvas
    mapContext.clearRect(0, 0, 512, 512);
    
    // Draw the tile image
    mapContext.drawImage(img, 0, 0, 512, 512);
    
    // Add region name overlay
    mapContext.fillStyle = 'rgba(0, 0, 0, 0.7)';
    mapContext.fillRect(10, 10, 150, 30);
    mapContext.fillStyle = 'white';
    mapContext.font = '16px Arial';
    mapContext.fillText(settings.region, 20, 30);
    
    // Create or update Three.js texture
    if (mapTexture) {
      mapTexture.needsUpdate = true;
    } else {
      mapTexture = new THREE.CanvasTexture(mapCanvas);
    }
    
    // Update ground plane material
    if (groundPlane) {
      groundPlane.material.map = mapTexture;
      groundPlane.material.needsUpdate = true;
    }
    
    // Update mini map ground plane too
    updateMiniMapGroundPlane();
  };
  
  img.onerror = function() {
    console.log('Failed to load tile, using fallback');
    // Create a fallback pattern if tile fails to load
    mapContext.fillStyle = '#4a7c59';
    mapContext.fillRect(0, 0, 512, 512);
    
    // Add a simple grid pattern
    mapContext.strokeStyle = '#3a5a2a';
    mapContext.lineWidth = 1;
    for (let i = 0; i < 512; i += 64) {
      mapContext.beginPath();
      mapContext.moveTo(i, 0);
      mapContext.lineTo(i, 512);
      mapContext.stroke();
      mapContext.beginPath();
      mapContext.moveTo(0, i);
      mapContext.lineTo(512, i);
      mapContext.stroke();
    }
    
    // Add region name
    mapContext.fillStyle = 'rgba(0, 0, 0, 0.7)';
    mapContext.fillRect(10, 10, 150, 30);
    mapContext.fillStyle = 'white';
    mapContext.font = '16px Arial';
    mapContext.fillText(settings.region, 20, 30);
    
    // Create texture even with fallback
    if (mapTexture) {
      mapTexture.needsUpdate = true;
    } else {
      mapTexture = new THREE.CanvasTexture(mapCanvas);
    }
    
    if (groundPlane) {
      groundPlane.material.map = mapTexture;
      groundPlane.material.needsUpdate = true;
    }
    
    updateMiniMapGroundPlane();
  };
  
  // Start loading the image
  img.src = tileUrl;
}

// Update region and regenerate data
function updateRegion(regionName) {
  settings.region = regionName;
  updateLeafletRegion(regionName);
  regenerateWindData();
  updateMiniMap(); // Update mini map when region changes
  updateMiniMapGroundPlane(); // Update mini map ground plane when region changes
}

// Regenerate wind data with current city pattern
function regenerateWindData() {
  // Clear existing cubes
  windCubes.forEach(cube => {
    scene.remove(cube);
  });
  windCubes = [];
  
  // Clear existing arrows
  windArrows.forEach(arrow => {
    scene.remove(arrow);
  });
  windArrows = [];
  
  // Generate new cubes and arrows
  generateWindCubes();
}

// Create reusable arrow geometry and material
function createArrowGeometry() {
  // Create streamlined arrow shape for wind flow visualization
  const shaftGeometry = new THREE.CylinderGeometry(0.03, 0.06, 1.0, 8); // Tapered shaft
  const headGeometry = new THREE.ConeGeometry(0.12, 0.3, 8); // Smaller, more streamlined head
  
  // Create arrow geometry by merging shaft and head
  arrowGeometry = new THREE.BufferGeometry();
  
  // Create matrices for positioning
  const shaftMatrix = new THREE.Matrix4();
  const headMatrix = new THREE.Matrix4();
  headMatrix.setPosition(0, 0.65, 0); // Position head at end of shaft
  
  // Merge geometries
  const shaftGeo = shaftGeometry.clone().applyMatrix4(shaftMatrix);
  const headGeo = headGeometry.clone().applyMatrix4(headMatrix);
  
  arrowGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([shaftGeo, headGeo]);
  
  // Create material - bright cyan with slight transparency for flowing effect
  arrowMaterial = new THREE.MeshLambertMaterial({
    color: 0x00ddff,
    transparent: true,
    opacity: 0.85
  });
}

// Generate realistic wind direction based on position and regional patterns
function generateWindDirection(x, y, z, windPattern) {
  // Flight level determines base wind characteristics
  const flightLevel = 50 + ((y / 2) * 50); // FL050 to FL500
  
  // Start with eastward direction, but vary significantly by altitude
  let directionAngle = 0; // Degrees from east (0° = due east)
  
  // Altitude-based wind pattern changes (major variations between flight levels)
  const altitudeLayerEffect = getAltitudeWindPattern(flightLevel, x, z);
  directionAngle += altitudeLayerEffect;
  
  // Add regional wind pattern influences (smaller variations)
  switch(windPattern) {
    case 'nor_easter':
      // Northeast: More varied at different altitudes
      directionAngle += (z * 2) + Math.sin(y * 0.8) * 15;
      break;
    case 'gulf_stream':
      // Southeast: Gulf Stream influence varies with altitude
      directionAngle += (x * 1.2) + Math.cos(y * 0.6) * 12;
      break;
    case 'continental':
      // Midwest: Continental flow patterns shift with altitude
      directionAngle += (x + z) * 0.8 + Math.sin(y * 0.5) * 18;
      break;
    case 'desert':
      // Southwest: Thermal patterns stronger at lower altitudes
      const thermalEffect = Math.max(0, 1 - (y / 10)); // Stronger at lower altitudes
      directionAngle += Math.sin(x * 0.4) * 10 * thermalEffect + Math.cos(y * 0.7) * 20;
      break;
    case 'pacific':
      // Northwest: Jet stream effects at higher altitudes
      const jetStreamEffect = Math.min(1, y / 8); // Stronger at higher altitudes
      directionAngle += 25 * jetStreamEffect + (z * 1.5) + Math.sin(y * 0.4) * 25;
      break;
    case 'plains':
      // Great Plains: Storm system influences vary with height
      directionAngle += (x - z) * 1.2 + Math.cos(y * 0.6) * 16;
      break;
  }
  
  // Add time-based variations that interact with altitude
  const timeSeed = currentDate.getTime() + currentTime.hour;
  const timeAltitudeInteraction = Math.sin(timeSeed + x * 30 + y * 40 + z * 35) * (5 + y * 2);
  directionAngle += timeAltitudeInteraction;
  
  // Convert angle to radians and create direction vector
  const angleRad = (directionAngle * Math.PI) / 180;
  const direction = new THREE.Vector3(
    Math.cos(angleRad), // X component (east-west)
    0, // Keep horizontal 
    Math.sin(angleRad) // Z component (north-south)
  ).normalize();
  
  return direction;
}

// Generate altitude-specific wind layer patterns
function getAltitudeWindPattern(flightLevel, x, z) {
  let layerEffect = 0;
  
  if (flightLevel <= 100) {
    // Low altitude (FL050-FL100): Surface effects, more variable
    layerEffect = Math.sin((x + z) * 0.6) * 25 + Math.cos(x * 0.8) * 15;
  } else if (flightLevel <= 200) {
    // Mid-low altitude (FL150-FL200): Transition layer
    layerEffect = Math.sin((x - z) * 0.4) * 20 + Math.cos(z * 0.7) * 18;
  } else if (flightLevel <= 300) {
    // Mid altitude (FL250-FL300): More organized flow
    layerEffect = Math.cos((x + z) * 0.3) * 15 + Math.sin(x * 0.5) * 12;
  } else if (flightLevel <= 400) {
    // High altitude (FL350-FL400): Jet stream influence
    layerEffect = 30 + Math.sin(z * 0.2) * 10 + Math.cos(x * 0.3) * 8; // More westerly
  } else {
    // Very high altitude (FL450-FL500): Strong jet stream
    layerEffect = 45 + Math.cos((x - z) * 0.2) * 12 + Math.sin(x * 0.25) * 6; // Very westerly
  }
  
  return layerEffect;
}

// Create ground plane with Leaflet map texture
function createGroundPlane() {
  const geometry = new THREE.PlaneGeometry(20, 20);
  
  // Create initial texture canvas
  mapCanvas = document.createElement('canvas');
  mapCanvas.width = 512;
  mapCanvas.height = 512;
  mapContext = mapCanvas.getContext('2d');
  
  // Fill with initial pattern
  mapContext.fillStyle = '#4a7c59';
  mapContext.fillRect(0, 0, 512, 512);
  
  // Create initial texture
  mapTexture = new THREE.CanvasTexture(mapCanvas);
  
  // Create material with texture
  const material = new THREE.MeshLambertMaterial({ map: mapTexture });
  groundPlane = new THREE.Mesh(geometry, material);
  groundPlane.rotation.x = -Math.PI / 2;
  groundPlane.position.y = -1;
  scene.add(groundPlane);
  
  // Initialize Leaflet map and load real texture
  initLeafletMap();
}

// Generate 10x10x10 wind cube grid with region-specific patterns (10 flight levels)
function generateWindCubes() {
  const windPattern = regions[settings.region].windPattern;
  
  for (let x = -9; x <= 9; x += 2) { // Centered grid from -9 to 9
    for (let y = 0; y < 10; y++) { // 10 flight levels
      for (let z = -9; z <= 9; z += 2) { // Centered grid from -9 to 9
        // Map y levels to standard flight levels FL050-FL500 in increments of 50
        const flightLevel = 50 + (y * 50); // FL050, FL100, FL150, ... FL500
        
        // Generate wind speed based on regional pattern
        let speed = getWindSpeedForPattern(windPattern, x, y * 2, z); // Scale y for pattern
        
        createWindCube(x, y * 2, z, Math.round(speed), flightLevel); // Space cubes 2 units apart vertically
      }
    }
  }
}

// Get wind speed based on region-specific patterns
function getWindSpeedForPattern(pattern, x, y, z) {
  const baseSpeed = 10 + (y * 2.5); // Speed increases with altitude
  let speed = baseSpeed;
  
  // Add time-based variation (hour of day affects wind patterns)
  const hourFactor = Math.sin((currentTime.hour / 24) * 2 * Math.PI) * 5;
  
  // Add date-based variation (day of year affects seasonal patterns)
  const dayOfYear = Math.floor((currentDate - new Date(currentDate.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);
  const seasonalFactor = Math.cos((dayOfYear / 365) * 2 * Math.PI) * 8;
  
  // Create a pseudo-random seed based on date and time for consistent patterns
  const timeSeed = currentDate.getTime() + currentTime.hour;
  const seededRandom = (Math.sin(timeSeed + x * 1000 + y * 100 + z * 10) + 1) / 2;
  
  switch(pattern) {
    case 'nor_easter':
      // Northeast: Strong easterly flows, coastal influence
      speed += (x + 10) * 1.8 + Math.sin(z * 0.4) * 8 + (seededRandom * 18 - 9);
      speed += hourFactor + seasonalFactor;
      break;
    case 'gulf_stream':
      // Southeast: Tropical patterns, gulf moisture influence
      const coastalEffect = Math.sin((z + 10) * 0.3) * 12;
      speed += coastalEffect + (seededRandom * 16 - 8);
      speed += hourFactor * 0.8 + seasonalFactor * 1.2;
      break;
    case 'continental':
      // Midwest: Variable continental patterns, lake effects
      const lakeEffect = Math.cos(x * 0.6) * Math.sin(z * 0.5) * 15;
      speed += lakeEffect + (seededRandom * 22 - 11);
      speed += hourFactor * 1.5 + seasonalFactor;
      break;
    case 'desert':
      // Southwest: Thermal updrafts, mountain wave patterns (stronger during day)
      const thermalEffect = Math.abs(x) + Math.abs(z);
      const thermalBoost = currentTime.hour >= 10 && currentTime.hour <= 16 ? 8 : 0;
      speed += thermalEffect * 0.8 + Math.sin(y * 0.4) * 10 + (seededRandom * 14 - 7);
      speed += thermalBoost + seasonalFactor * 0.5;
      break;
    case 'pacific':
      // Northwest: Strong westerly flow, marine layer influence
      speed += (10 - x) * 2.0 + Math.cos(y * 0.3) * 6 + (seededRandom * 16 - 8);
      speed += hourFactor * 0.6 + seasonalFactor * 1.3;
      break;
    case 'plains':
      // Great Plains: Prairie winds, storm system influence
      const stormEffect = Math.sin((x + z) * 0.4) * 12;
      speed += stormEffect + (seededRandom * 25 - 12.5);
      speed += hourFactor * 1.2 + seasonalFactor;
      break;
  }
  
  return Math.max(5, Math.min(100, speed));
}

// Create individual wind cube with basic material
function createWindCube(x, y, z, speed, flightLevel) {
  const geometry = new THREE.BoxGeometry(2, 2, 2); // Proper 2x2x2 cubes
  
  // Generate wind direction for this cube
  const windPattern = regions[settings.region].windPattern;
  const windDirection = generateWindDirection(x, y, z, windPattern);
  
  // Basic color mapping
  let color;
  if (speed < 20) {
    color = 0x00AA00; // Dark green - calm
  } else if (speed < 35) {
    color = 0x66FF66; // Light green - light
  } else if (speed < 50) {
    color = 0xFFFF00; // Yellow - moderate
  } else if (speed < 65) {
    color = 0xFF8800; // Orange - strong
  } else {
    color = 0xFF0000; // Red - very strong
  }
  
  // Create basic material
  const material = new THREE.MeshLambertMaterial({ 
    color: color,
    transparent: true,
    opacity: settings.cubeOpacity
  });
  
  const cube = new THREE.Mesh(geometry, material);
  cube.position.set(x, y, z);
  cube.userData = { 
    speed: speed, 
    flightLevel: flightLevel,
    yLevel: y / 2, // Adjust for hover grouping
    windDirection: windDirection // Store wind direction
  };
  
  // Create wind direction arrow (hidden by default)
  const arrow = new THREE.Mesh(arrowGeometry.clone(), arrowMaterial.clone());
  
  // Position arrow above the cube so it's clearly visible
  arrow.position.set(x, y + 1.5, z);
  
  // Base rotation to point east (WORKING!)
  arrow.rotation.x = Math.PI / 2; // Tip over 90° from up to forward (south)
  arrow.rotation.y = 0; // No Y rotation  
  arrow.rotation.z = -Math.PI / 2; // Z-axis turn from south to east
  
  // Add wind direction variation around Y-axis
  const windAngle = Math.atan2(windDirection.z, windDirection.x);
  arrow.rotation.y += windAngle * 0.3; // Small wind direction variation
  
  // Add banking/tilting for realistic wind flow patterns
  const bankingFactor = Math.sin((x + z) * 0.3) * 0.08; // Subtle banking variation
  const speedBanking = (speed - 50) / 300; // Faster winds bank more (reduced)
  const altitudeBanking = y * 0.005; // Higher altitudes have more banking (reduced)
  
  // Apply banking as additional Z rotation
  arrow.rotation.z += bankingFactor + speedBanking + altitudeBanking;
  
  // Scale arrow based on wind speed (shorter, more reasonable size)
  const arrowScale = 0.4 + (speed / 100) * 0.3; // Scale from 0.4 to 0.7 (reasonable size)
  arrow.scale.setScalar(arrowScale);
  
  // Hide arrow by default
  arrow.visible = false;
  arrow.userData = { 
    cubeIndex: windCubes.length, // Reference to parent cube
    yLevel: y / 2
  };
  
  scene.add(cube);
  scene.add(arrow);
  windCubes.push(cube);
  windArrows.push(arrow);
}

// Create flight level labels
function createFlightLevelLabels() {
  // Show labels at each flight level (every 2 y-units = 50 flight level increment)
  for (let y = 0; y < 20; y += 2) {
    const flightLevel = 50 + ((y / 2) * 50);
    const flStr = String(flightLevel).padStart(3, '0');
    createTextSprite(`FL${flStr}`, 11, y, 0);
  }
  
  // Add compass directions on the ground plane
  createCompassLabels();
}

// Create compass direction labels
function createCompassLabels() {
  // N, S, E, W labels around the ground plane edges
  createTextSprite('N', 0, 0, -11);  // North - negative Z (away from viewer)
  createTextSprite('S', 0, 0, 11);   // South - positive Z (toward viewer)
  createTextSprite('E', 11, 0, 0);   // East - positive X
  createTextSprite('W', -11, 0, 0);  // West - negative X
}

// Create text sprite for labels
function createTextSprite(text, x, y, z) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;
  
  context.fillStyle = 'rgba(0, 0, 0, 0.8)';
  context.fillRect(0, 0, canvas.width, canvas.height);
  
  context.fillStyle = 'white';
  context.font = '24px Geist, system-ui, sans-serif';
  context.textAlign = 'center';
  context.fillText(text, canvas.width / 2, 40);
  
  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture });
  const sprite = new THREE.Sprite(material);
  
  sprite.position.set(x, y, z);
  sprite.scale.set(4, 1, 1);
  scene.add(sprite);
}

// Create tooltip element
function createTooltip() {
  tooltip = document.createElement('div');
  tooltip.id = 'tooltip';
  tooltip.style.position = 'absolute';
  tooltip.style.backgroundColor = 'rgba(0, 20, 40, 0.9)';
  tooltip.style.color = 'white';
  tooltip.style.padding = '8px 12px';
  tooltip.style.borderRadius = '6px';
  tooltip.style.fontSize = '14px';
  tooltip.style.fontFamily = 'Geist, system-ui, sans-serif';
  tooltip.style.pointerEvents = 'none';
  tooltip.style.zIndex = '1000';
  tooltip.style.display = 'none';
  tooltip.style.whiteSpace = 'nowrap';
  tooltip.style.border = '2px solid white';
  tooltip.style.boxShadow = '0 0 20px white';
  tooltip.style.backdropFilter = 'blur(8px)';
  tooltip.style.webkitBackdropFilter = 'blur(8px)';
  document.body.appendChild(tooltip);
}

// Initialize mini map
function initMiniMap() {
  miniMapContainer = document.getElementById('mini-map-container');
  miniMapCanvas = document.getElementById('mini-map-canvas');
  
  // Set up mini map scene
  miniMapScene = new THREE.Scene();
  miniMapScene.background = new THREE.Color(0x000000);
  
  // Set up orthographic camera for top-down view
  miniMapCamera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 100);
  miniMapCamera.position.set(0, 50, 0);
  miniMapCamera.lookAt(0, 0, 0);
  
  // Set up mini map renderer
  miniMapRenderer = new THREE.WebGLRenderer({ canvas: miniMapCanvas, antialias: true });
  
  // Set initial size based on container
  const containerRect = miniMapContainer.getBoundingClientRect();
  miniMapRenderer.setSize(containerRect.width - 8, containerRect.height - 8); // Account for border
  
  // Add lighting
  const miniMapLight = new THREE.AmbientLight(0xffffff, 1.0);
  miniMapScene.add(miniMapLight);
  
  // Create ground plane for mini map
  const miniMapGeometry = new THREE.PlaneGeometry(20, 20);
  const miniMapMaterial = new THREE.MeshLambertMaterial({ color: 0x4a7c59 });
  miniMapGroundPlane = new THREE.Mesh(miniMapGeometry, miniMapMaterial);
  miniMapGroundPlane.rotation.x = -Math.PI / 2;
  miniMapGroundPlane.position.y = -1;
  miniMapScene.add(miniMapGroundPlane);
}

// Update mini map when flight level is selected
function updateMiniMap() {
  if (!miniMapRenderer) return;
  
  if (selectedFlightLevel !== null) {
    // Show mini map
    miniMapContainer.classList.add('visible');
    
    // Clear existing mini map cubes
    miniMapCubes.forEach(cube => {
      miniMapScene.remove(cube);
    });
    miniMapCubes = [];
    
    // Clear existing HTML arrows
    miniMapArrows.forEach(arrow => {
      miniMapContainer.removeChild(arrow);
    });
    miniMapArrows = [];
    
    // Add selected flight level cubes to mini map
    windCubes.forEach(cube => {
      if (cube.userData.yLevel === selectedFlightLevel) {
        const miniCube = cube.clone();
        miniCube.position.copy(cube.position);
        miniCube.position.y = 0; // Flatten to ground level for top view
        miniCube.material = cube.material.clone();
        miniCube.material.opacity = 0.3; // Further reduced opacity to see map better
        miniMapScene.add(miniCube);
        miniMapCubes.push(miniCube);
        
        // Create HTML arrow for this cube
        createMiniMapArrow(cube);
      }
    });
  } else {
    // Hide mini map
    miniMapContainer.classList.remove('visible');
    
    // Clear HTML arrows when hiding
    miniMapArrows.forEach(arrow => {
      miniMapContainer.removeChild(arrow);
    });
    miniMapArrows = [];
  }
}

// Create HTML arrow for mini map
function createMiniMapArrow(cube) {
  const arrow = document.createElement('div');
  arrow.className = 'mini-map-arrow';
  
  // Get wind direction data from the cube
  const windDirection = cube.userData.windDirection;
  
  // Calculate position in mini map coordinates
  // Convert world position (-10 to 10) to mini map percentage (0% to 100%)
  const containerRect = miniMapContainer.getBoundingClientRect();
  const mapSize = containerRect.width - 8; // Account for border
  
  // Map world coordinates to mini map coordinates
  const worldX = cube.position.x; // -9 to 9
  const worldZ = cube.position.z; // -9 to 9
  
  // Convert to 0-1 range, then to pixels
  const normalizedX = (worldX + 10) / 20; // Convert -10 to 10 to 0 to 1
  const normalizedZ = (worldZ + 10) / 20; // Convert -10 to 10 to 0 to 1
  
  const pixelX = normalizedX * mapSize;
  const pixelZ = normalizedZ * mapSize;
  
  // Position arrow (remember Y is flipped in CSS, and it's a top-down view)
  arrow.style.left = `${pixelX}px`;
  arrow.style.top = `${pixelZ}px`;
  
  // Calculate rotation angle from wind direction (top-down view)
  // In top-down view: X = right, Z = down
  const windAngle = Math.atan2(windDirection.z, windDirection.x) * 180 / Math.PI;
  
  // Add banking effect based on wind speed and position
  const speed = cube.userData.speed;
  const bankingEffect = Math.sin((cube.position.x + cube.position.z) * 0.3) * 5; // ±5 degrees
  const speedBanking = (speed - 50) / 10; // Faster winds get more banking
  
  const totalRotation = windAngle + bankingEffect + speedBanking;
  
  // Apply rotation and banking
  arrow.style.transform = `translate(-50%, -100%) rotate(${totalRotation}deg)`;
  
  // Scale based on wind speed
  const scale = 0.6 + (speed / 100) * 0.4; // Scale from 0.6 to 1.0
  arrow.style.transform += ` scale(${scale})`;
  
  // Set initial visibility based on setting
  arrow.style.display = settings.showWindArrows ? 'block' : 'none';
  
  // Add to container and track
  miniMapContainer.appendChild(arrow);
  miniMapArrows.push(arrow);
  
  // Store cube reference for position updates
  arrow.dataset.cubeIndex = windCubes.indexOf(cube);
}

// Update mini map arrow positions after resize
function updateMiniMapArrowPositions() {
  const containerRect = miniMapContainer.getBoundingClientRect();
  const mapSize = containerRect.width - 8; // Account for border
  
  miniMapArrows.forEach(arrow => {
    const cubeIndex = parseInt(arrow.dataset.cubeIndex);
    const cube = windCubes[cubeIndex];
    
    if (cube && cube.userData.yLevel === selectedFlightLevel) {
      // Recalculate position
      const worldX = cube.position.x;
      const worldZ = cube.position.z;
      
      const normalizedX = (worldX + 10) / 20;
      const normalizedZ = (worldZ + 10) / 20;
      
      const pixelX = normalizedX * mapSize;
      const pixelZ = normalizedZ * mapSize;
      
      // Update position
      arrow.style.left = `${pixelX}px`;
      arrow.style.top = `${pixelZ}px`;
    }
  });
}

// Update mini map ground plane when region changes
function updateMiniMapGroundPlane() {
  if (!miniMapGroundPlane) return;
  
  // Use the same texture as the main ground plane with subtle brightness enhancement
  if (mapTexture) {
    // Clone the material to avoid affecting the main ground plane
    miniMapGroundPlane.material = new THREE.MeshLambertMaterial({ 
      map: mapTexture,
      color: 0xcccccc // Slightly brighter than normal (light gray tint)
    });
    
    // Add very subtle emissive for better visibility
    miniMapGroundPlane.material.emissive = new THREE.Color(0x111111);
    miniMapGroundPlane.material.needsUpdate = true;
  }
}

// Handle mouse movement for interactions
function onMouseMove(event) {
  // Skip if currently resizing mini map
  if (isResizing) {
    return;
  }
  
  const canvas = renderer.domElement;
  const rect = canvas.getBoundingClientRect();
  
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(windCubes);
  
  if (intersects.length > 0) {
    const hoveredCube = intersects[0].object;
    const hoveredYLevel = hoveredCube.userData.yLevel;
    const flightLevel = hoveredCube.userData.flightLevel;
    const windSpeed = hoveredCube.userData.speed;
    isHovering = true;
    
    // Change cursor to pointer when hovering over cubes
    canvas.style.cursor = 'pointer';
    
    // Show tooltip with flight level info
    tooltip.style.display = 'block';
    tooltip.style.left = (event.clientX + 10) + 'px';
    tooltip.style.top = (event.clientY - 10) + 'px';
    
    // Calculate grid coordinates (convert from world position to grid reference)
    const gridX = Math.round((hoveredCube.position.x + 9) / 2);
    const gridZ = Math.round((hoveredCube.position.z + 9) / 2);
    
    // Calculate wind direction in degrees (from wind direction vector)
    const windDir = hoveredCube.userData.windDirection;
    const windAngle = Math.atan2(windDir.z, windDir.x) * 180 / Math.PI;
    const windDirection = ((windAngle + 360) % 360).toFixed(0); // Convert to 0-360 degrees
    
    tooltip.innerHTML = `FL${String(flightLevel).padStart(3, '0')}<br/>Wind: ${windSpeed} kt @ ${windDirection}°<br/>Grid: ${gridX}, ${gridZ}`;
    
    // Only apply hover effects if no flight level is currently selected
    if (selectedFlightLevel === null) {
      // Apply hover effects
      windCubes.forEach(cube => {
        let targetOpacity;
        if (cube.userData.yLevel === hoveredYLevel) {
          // Highlight hovered level (preview)
          targetOpacity = 0.4;
        } else {
          // Dim other levels using GUI setting
          targetOpacity = settings.cubeOpacity;
        }
        
        cube.material.opacity = targetOpacity;
      });
      
      // Show arrows for hovered level (only if arrows are enabled and no selection)
      windArrows.forEach(arrow => {
        if (settings.showWindArrows && arrow.userData.yLevel === hoveredYLevel) {
          arrow.visible = true;
        } else {
          arrow.visible = false;
        }
      });
    }
    // If a flight level is selected, maintain current visual state (no hover effects)
  } else {
    isHovering = false;
    
    // Change cursor to move when not hovering over cubes (orbit mode)
    canvas.style.cursor = 'move';
    
    // Hide tooltip
    tooltip.style.display = 'none';
    
    // Restore appropriate state based on whether a flight level is selected
    if (selectedFlightLevel !== null) {
      // Maintain selection state (no changes needed - selection is locked)
      // Visual state should remain as it was when selection was made
    } else {
      // No selection - restore default hover-off state
      // Hide all arrows when no selection and not hovering
      windArrows.forEach(arrow => {
        arrow.visible = false;
      });
      // Opacity will be handled by distance calculation in animate()
    }
  }
}

// Handle mouse down to track drag start
function onMouseDown(event) {
  mouseDownPosition.x = event.clientX;
  mouseDownPosition.y = event.clientY;
  isDragging = false;
}

// Handle mouse up to detect drag vs click
function onMouseUp(event) {
  const deltaX = Math.abs(event.clientX - mouseDownPosition.x);
  const deltaY = Math.abs(event.clientY - mouseDownPosition.y);
  const dragThreshold = 5; // pixels
  
  isDragging = deltaX > dragThreshold || deltaY > dragThreshold;
}

// Handle mouse clicks for selection
function onMouseClick(event) {
  // Skip if currently resizing mini map
  if (isResizing) {
    return;
  }
  
  // Only process click if it wasn't a drag (orbit controls)
  if (isDragging) {
    return;
  }
  
  const canvas = renderer.domElement;
  const rect = canvas.getBoundingClientRect();
  
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(windCubes);
  
  if (intersects.length > 0) {
    const clickedCube = intersects[0].object;
    const clickedYLevel = clickedCube.userData.yLevel;
    
    // If clicking the same level, deselect
    if (selectedFlightLevel === clickedYLevel) {
      deselectFlightLevel();
    } else {
      selectFlightLevel(clickedYLevel);
    }
  }
  // Removed background deselection - only cube clicks affect selection
}

// Touch event handlers for mobile support
function onTouchStart(event) {
  event.preventDefault(); // Prevent default touch behaviors like scrolling
  
  if (event.touches.length === 1) {
    const touch = event.touches[0];
    mouseDownPosition.x = touch.clientX;
    mouseDownPosition.y = touch.clientY;
    isDragging = false;
  }
}

function onTouchMove(event) {
  event.preventDefault(); // Prevent default touch behaviors like scrolling
  
  if (event.touches.length === 1) {
    const touch = event.touches[0];
    const canvas = renderer.domElement;
    const rect = canvas.getBoundingClientRect();
    
    mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(windCubes);
    
    if (intersects.length > 0) {
      const hoveredCube = intersects[0].object;
      const hoveredYLevel = hoveredCube.userData.yLevel;
      const flightLevel = hoveredCube.userData.flightLevel;
      const windSpeed = hoveredCube.userData.speed;
      isHovering = true;
      
      // Show tooltip with flight level info
      tooltip.style.display = 'block';
      tooltip.style.left = (touch.clientX + 10) + 'px';
      tooltip.style.top = (touch.clientY - 10) + 'px';
      
      // Calculate grid coordinates (convert from world position to grid reference)
      const gridX = Math.round((hoveredCube.position.x + 9) / 2);
      const gridZ = Math.round((hoveredCube.position.z + 9) / 2);
      
      // Calculate wind direction in degrees (from wind direction vector)
      const windDir = hoveredCube.userData.windDirection;
      const windAngle = Math.atan2(windDir.z, windDir.x) * 180 / Math.PI;
      const windDirection = ((windAngle + 360) % 360).toFixed(0); // Convert to 0-360 degrees
      
      tooltip.innerHTML = `FL${String(flightLevel).padStart(3, '0')}<br/>Wind: ${windSpeed} kt @ ${windDirection}°<br/>Grid: ${gridX}, ${gridZ}`;
      
      // Only apply hover effects if no flight level is currently selected
      if (selectedFlightLevel === null) {
        // Apply hover effects
        windCubes.forEach(cube => {
          let targetOpacity;
          if (cube.userData.yLevel === hoveredYLevel) {
            // Highlight hovered level (preview)
            targetOpacity = 0.4;
          } else {
            // Dim other levels using GUI setting
            targetOpacity = settings.cubeOpacity;
          }
          
          cube.material.opacity = targetOpacity;
        });
        
        // Show arrows for hovered level (only if arrows are enabled and no selection)
        windArrows.forEach(arrow => {
          if (settings.showWindArrows && arrow.userData.yLevel === hoveredYLevel) {
            arrow.visible = true;
          } else {
            arrow.visible = false;
          }
        });
      }
      // If a flight level is selected, maintain current visual state (no hover effects)
    } else {
      isHovering = false;
      
      // Hide tooltip
      tooltip.style.display = 'none';
      
      // Restore selection state or default opacity
      if (selectedFlightLevel !== null) {
        // Restore selection state
        windCubes.forEach(cube => {
          let targetOpacity;
          if (cube.userData.yLevel === selectedFlightLevel) {
            targetOpacity = 0.5; // Keep selected level bright
          } else {
            targetOpacity = settings.cubeOpacity; // Use GUI setting
          }
          
          cube.material.opacity = targetOpacity;
        });
        
        // Show arrows only for selected level when not hovering
        windArrows.forEach(arrow => {
          arrow.visible = arrow.userData.yLevel === selectedFlightLevel;
        });
      } else {
        // Hide all arrows when no selection and not hovering
        windArrows.forEach(arrow => {
          arrow.visible = false;
        });
      }
    }
  }
}

function onTouchEnd(event) {
  event.preventDefault(); // Prevent default touch behaviors like scrolling
  
  if (event.changedTouches.length === 1) {
    const touch = event.changedTouches[0];
    const deltaX = Math.abs(touch.clientX - mouseDownPosition.x);
    const deltaY = Math.abs(touch.clientY - mouseDownPosition.y);
    const dragThreshold = 5; // pixels
    
    isDragging = deltaX > dragThreshold || deltaY > dragThreshold;
    
    // Only process tap if it wasn't a drag (orbit controls)
    if (!isDragging) {
      const canvas = renderer.domElement;
      const rect = canvas.getBoundingClientRect();
      
      mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(windCubes);
      
      if (intersects.length > 0) {
        const tappedCube = intersects[0].object;
        const tappedYLevel = tappedCube.userData.yLevel;
        
        // If tapping the same level, deselect
        if (selectedFlightLevel === tappedYLevel) {
          deselectFlightLevel();
        } else {
          selectFlightLevel(tappedYLevel);
        }
      }
    }
    
    // Always hide tooltip when touch ends
    tooltip.style.display = 'none';
    isHovering = false;
    
    // Restore proper opacity state
    if (selectedFlightLevel !== null) {
      // Maintain selection state (locked - no changes)
      // Visual state should remain as it was when selection was made
    } else {
      // No selection - restore default state
      windArrows.forEach(arrow => {
        arrow.visible = false;
      });
    }
  }
}

// Mini map resize event handlers
function onMiniMapResizeStart(event) {
  event.preventDefault();
  event.stopPropagation();
  
  isResizing = true;
  
  const containerRect = miniMapContainer.getBoundingClientRect();
  resizeStartSize.width = containerRect.width;
  resizeStartSize.height = containerRect.height;
  
  if (event.type === 'mousedown') {
    resizeStartMouse.x = event.clientX;
    resizeStartMouse.y = event.clientY;
    
    document.addEventListener('mousemove', onMiniMapResize, true); // Use capture
    document.addEventListener('mouseup', onMiniMapResizeEnd, true); // Use capture
  } else if (event.type === 'touchstart') {
    const touch = event.touches[0];
    resizeStartMouse.x = touch.clientX;
    resizeStartMouse.y = touch.clientY;
    
    document.addEventListener('touchmove', onMiniMapResize, { passive: false, capture: true });
    document.addEventListener('touchend', onMiniMapResizeEnd, { capture: true });
  }
}

function onMiniMapResize(event) {
  if (!isResizing) return;
  
  event.preventDefault();
  event.stopPropagation();
  
  let clientX, clientY;
  if (event.type === 'mousemove') {
    clientX = event.clientX;
    clientY = event.clientY;
  } else if (event.type === 'touchmove') {
    const touch = event.touches[0];
    clientX = touch.clientX;
    clientY = touch.clientY;
  }
  
  const deltaX = clientX - resizeStartMouse.x;
  const deltaY = -(clientY - resizeStartMouse.y); // Invert Y because handle is at top
  
  // Use the larger delta to maintain 1:1 aspect ratio
  const delta = Math.max(deltaX, deltaY);
  
  // Get constraints based on screen size
  const isSmallScreen = window.innerWidth <= 768;
  const minSize = isSmallScreen ? 120 : 150;
  const maxSize = isSmallScreen ? 300 : 400;
  
  // Apply same size to both width and height (square aspect ratio)
  const newSize = Math.max(minSize, Math.min(maxSize, resizeStartSize.width + delta));
  
  // Update container size
  miniMapContainer.style.width = newSize + 'px';
  miniMapContainer.style.height = newSize + 'px';
  
  // Update renderer size
  miniMapRenderer.setSize(newSize - 8, newSize - 8); // Account for border
  
  // Update mini map arrow positions after resize
  if (selectedFlightLevel !== null) {
    updateMiniMapArrowPositions();
  }
}

function onMiniMapResizeEnd(event) {
  if (event) {
    event.preventDefault();
    event.stopPropagation();
  }
  
  isResizing = false;
  
  // Remove event listeners with matching options
  document.removeEventListener('mousemove', onMiniMapResize, true);
  document.removeEventListener('mouseup', onMiniMapResizeEnd, true);
  document.removeEventListener('touchmove', onMiniMapResize, { passive: false, capture: true });
  document.removeEventListener('touchend', onMiniMapResizeEnd, { capture: true });
  
  // Failsafe: also remove without capture in case there was a mismatch
  document.removeEventListener('mousemove', onMiniMapResize);
  document.removeEventListener('mouseup', onMiniMapResizeEnd);
  document.removeEventListener('touchmove', onMiniMapResize);
  document.removeEventListener('touchend', onMiniMapResizeEnd);
}

// Select a flight level
function selectFlightLevel(yLevel) {
  // Clear previous selection
  deselectFlightLevel();
  
  selectedFlightLevel = yLevel;
  
  // Add white wireframes to selected cubes and set opacity
  windCubes.forEach(cube => {
    if (cube.userData.yLevel === yLevel) {
      // Highlight selected level
      cube.material.opacity = 0.5;
      
      // Add wireframe outline
      const wireframeGeometry = new THREE.BoxGeometry(2, 2, 2);
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff, // White wireframe
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
      wireframe.position.copy(cube.position);
      scene.add(wireframe);
      selectedCubes.push(wireframe);
    } else {
      // Use GUI setting for dimmed levels
      cube.material.opacity = settings.cubeOpacity;
    }
  });
  
  // Show arrows for selected level (only if arrows are enabled)
  windArrows.forEach(arrow => {
    arrow.visible = settings.showWindArrows && arrow.userData.yLevel === yLevel;
  });
  updateMiniMap(); // Update mini map when flight level is selected
}

// Deselect current flight level
function deselectFlightLevel() {
  selectedFlightLevel = null;
  
  // Remove all wireframes
  selectedCubes.forEach(wireframe => {
    scene.remove(wireframe);
  });
  selectedCubes = [];
  
  // Reset all cube opacities to default
  windCubes.forEach(cube => {
    cube.material.opacity = settings.cubeOpacity;
  });
  
  // Hide all arrows
  windArrows.forEach(arrow => {
    arrow.visible = false;
  });
  updateMiniMap(); // Update mini map when flight level is deselected
}

// Handle window resize
function onWindowResize() {
  const canvas = renderer.domElement;
  const rect = canvas.getBoundingClientRect();
  
  camera.aspect = rect.width / rect.height;
  camera.updateProjectionMatrix();
  renderer.setSize(rect.width, rect.height);
}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  // Update controls
  controls.update();

  // Update cube opacity based on camera distance only when not hovering and not selected
  if (!isHovering && selectedFlightLevel === null) {
    const cameraPosition = camera.position;
    windCubes.forEach(cube => {
      const distance = cameraPosition.distanceTo(cube.position);
      const opacity = Math.max(0.02, Math.min(settings.cubeOpacity, (80 - distance) / 80)); // Use GUI setting as max
      cube.material.opacity = opacity;
    });
  }
  // When a flight level is selected, maintain the locked visual state (no distance-based opacity changes)
  
  // Animate wind arrows for more dynamic flow
  const time = Date.now() * 0.001; // Current time in seconds
  windArrows.forEach((arrow, index) => {
    if (arrow.visible) {
      // Add subtle oscillation to make wind look alive
      // Store the base Z rotation if not already stored
      if (arrow.userData.baseRotationZ === undefined) {
        arrow.userData.baseRotationZ = arrow.rotation.z;
      }
      
      // Add gentle oscillation
      const oscillation = Math.sin(time * 1.5 + index * 0.2) * 0.03; // Very subtle
      arrow.rotation.z = arrow.userData.baseRotationZ + oscillation;
    }
  });
  
  // Animate mini map HTML arrows too
  miniMapArrows.forEach((arrow, index) => {
    if (!arrow.dataset.baseRotation) {
      // Extract base rotation from current transform
      const currentTransform = arrow.style.transform;
      const rotateMatch = currentTransform.match(/rotate\(([^)]+)deg\)/);
      if (rotateMatch) {
        arrow.dataset.baseRotation = rotateMatch[1];
      }
    }
    
    if (arrow.dataset.baseRotation) {
      const baseRotation = parseFloat(arrow.dataset.baseRotation);
      const oscillation = Math.sin(time * 1.5 + index * 0.2) * 2; // ±2 degrees
      const newRotation = baseRotation + oscillation;
      
      // Update transform while preserving other parts
      const currentTransform = arrow.style.transform;
      const newTransform = currentTransform.replace(
        /rotate\([^)]+deg\)/,
        `rotate(${newRotation}deg)`
      );
      arrow.style.transform = newTransform;
    }
  });
  
  // Render main scene
  renderer.render(scene, camera);
  
  // Render mini map if visible
  if (miniMapRenderer && selectedFlightLevel !== null) {
    miniMapRenderer.render(miniMapScene, miniMapCamera);
  }
}

// Update cube opacity based on GUI setting
function updateCubeOpacity() {
  // Only update if no specific hover/selection state is active
  if (!isHovering && selectedFlightLevel === null) {
    windCubes.forEach(cube => {
      cube.material.opacity = settings.cubeOpacity;
    });
  } else if (selectedFlightLevel !== null) {
    // Update dimmed cubes in locked selection state
    windCubes.forEach(cube => {
      if (cube.userData.yLevel !== selectedFlightLevel) {
        cube.material.opacity = settings.cubeOpacity;
      }
      // Keep selected level bright (don't change its opacity)
    });
  }
}

// Start the visualization
initScene();
animate(); 
</script>