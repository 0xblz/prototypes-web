---
layout: default
title: wind vector
description: three.js 3d experiment
prototype: true
---
<style>
.preview {
    max-width: 1200px;
    min-height: 320px;
    padding: 0;
}

canvas {
  display: flex;
  flex-direction: column;
  width: 100%;
  flex: 1;
}

#mini-map-canvas {
  position: absolute;
  bottom: 20px;
  left: 20px;
  width: 200px;
  height: 200px;
  border: 4px solid #00ffff;
  border-radius: 8px;
  background: rgba(0, 0, 0, 0.8);
  z-index: 10;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease;
  box-shadow: 0 0 2rem 0 rgba(0, 255, 255, 0.4);
}

#mini-map-canvas.visible {
  opacity: 1;
}

@media (max-width: 768px) {
  #mini-map-canvas {
    width: 150px;
    height: 150px;
    bottom: 15px;
    left: 15px;
  }
}

/* UI Enhancement styles */
body {
  background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
}

#tooltip {
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(0, 255, 255, 0.3);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
}
</style>

<canvas id="three-canvas"></canvas>
<canvas id="mini-map-canvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
<!-- Post-processing dependencies -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.min.js"></script>

<script>
// 3D Wind Vector Visualization
let scene, camera, renderer, controls;
let composer; // Post-processing composer
let windCubes = [];
let flightLevelGroups = [];
let groundPlane;
let raycaster, mouse;
let isHovering = false; // Track hover state
let selectedFlightLevel = null; // Track selected flight level
let selectedCubes = []; // Track selected cube outlines
let mouseDownPosition = { x: 0, y: 0 }; // Track mouse down position
let isDragging = false; // Track if user is dragging
let gui; // dat.GUI instance
let tooltip; // Tooltip element
let clock = new THREE.Clock(); // For animations
let time = 0;

// Mini map variables
let miniMapScene, miniMapCamera, miniMapRenderer;
let miniMapCanvas;
let miniMapGroundPlane;
let miniMapCubes = [];

// GUI settings
const settings = {
  region: 'Northeast',
  cubeOpacity: 0.08, // Default cube opacity
  enableEffects: false, // Toggle for all visual enhancements (default: OFF)
  randomizeWind: function() {
    regenerateWindData();
  }
};

// Regional configurations
const regions = {
  'Northeast': {
    mapUrl: 'https://tile.openstreetmap.org/5/9/12.png', // Northeast US
    windPattern: 'nor_easter' // Nor'easter and Atlantic influence
  },
  'Southeast': {
    mapUrl: 'https://tile.openstreetmap.org/5/8/13.png', // Southeast US  
    windPattern: 'gulf_stream' // Gulf Stream and tropical influence
  },
  'Midwest': {
    mapUrl: 'https://tile.openstreetmap.org/5/7/11.png', // Great Lakes region
    windPattern: 'continental' // Continental and lake effect patterns
  },
  'Southwest': {
    mapUrl: 'https://tile.openstreetmap.org/5/5/12.png', // Desert Southwest
    windPattern: 'desert' // Desert thermal and mountain wave patterns
  },
  'Northwest': {
    mapUrl: 'https://tile.openstreetmap.org/5/5/10.png', // Pacific Northwest
    windPattern: 'pacific' // Pacific maritime influence
  },
  'Great Plains': {
    mapUrl: 'https://tile.openstreetmap.org/5/7/12.png', // Central Plains
    windPattern: 'plains' // Prairie winds and storm systems
  }
};

// Initialize the scene
function initScene() {
  // Scene setup
  scene = new THREE.Scene();
  // Set background based on effects setting
  if (settings.enableEffects) {
    scene.background = new THREE.Color(0x0a0a1a); // Dark blue/purple background for UI feel
  } else {
    scene.background = new THREE.Color(0xDBDDEB); // Original light background
  }

  // Get canvas and set up responsive sizing
  const canvas = document.getElementById('three-canvas');
  const rect = canvas.getBoundingClientRect();
  
  // Camera setup
  camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);
  camera.position.set(15, 20, 15);
  
  // Renderer setup
  renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
  renderer.setSize(rect.width, rect.height);
  renderer.setPixelRatio(window.devicePixelRatio);

  // Setup lighting based on effects setting
  if (settings.enableEffects) {
    // Enhanced lighting for UI feel
    const ambientLight = new THREE.AmbientLight(0x404080, 0.6); // Slightly blue ambient
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0x80a0ff, 0.8); // Cool directional light
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);
  } else {
    // Original basic lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Bright white ambient light
    scene.add(ambientLight);
  }
  
  // Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // Raycaster for interactions
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  // Create ground plane
  createGroundPlane();
  
  // Generate wind cubes
  generateWindCubes();
  
  // Create flight level labels
  createFlightLevelLabels();
  
  // Setup post-processing
  setupPostProcessing();
  
  // Create GUI
  createGUI();
  
  // Create tooltip
  createTooltip();
  
  // Initialize mini map
  initMiniMap();
  
  // Add event listeners
  canvas.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('mousedown', onMouseDown);
  canvas.addEventListener('mouseup', onMouseUp);
  canvas.addEventListener('click', onMouseClick);
  
  // Add touch event listeners for mobile support
  canvas.addEventListener('touchstart', onTouchStart, { passive: false });
  canvas.addEventListener('touchmove', onTouchMove, { passive: false });
  canvas.addEventListener('touchend', onTouchEnd, { passive: false });
  
  window.addEventListener('resize', onWindowResize);
}

// Setup post-processing pipeline
function setupPostProcessing() {
  // Create composer
  composer = new THREE.EffectComposer(renderer);
  
  // Add render pass
  const renderPass = new THREE.RenderPass(scene, camera);
  composer.addPass(renderPass);
  
  // Add custom UI effects shader pass
  const uiEffectsPass = new THREE.ShaderPass({
    uniforms: {
      tDiffuse: { value: null },
      time: { value: 0 },
      glitchAmount: { value: 0.003 },
      scanlineIntensity: { value: 0.02 },
      vignetteStrength: { value: 0.3 },
      chromaticAberration: { value: 0.002 }
    },
    vertexShader: `
      varying vec2 vUv;
      
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform sampler2D tDiffuse;
      uniform float time;
      uniform float glitchAmount;
      uniform float scanlineIntensity;
      uniform float vignetteStrength;
      uniform float chromaticAberration;
      
      varying vec2 vUv;
      
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
      }
      
      void main() {
        vec2 uv = vUv;
        
        // Chromatic aberration
        float aberration = chromaticAberration * (1.0 + sin(time * 0.5) * 0.5);
        vec2 dir = uv - vec2(0.5);
        float dist = length(dir);
        
        vec3 color;
        color.r = texture2D(tDiffuse, uv + dir * aberration * dist).r;
        color.g = texture2D(tDiffuse, uv).g;
        color.b = texture2D(tDiffuse, uv - dir * aberration * dist).b;
        
        // Subtle glitch effect
        float glitchSeed = floor(time * 8.0);
        float glitch = random(vec2(glitchSeed, floor(uv.y * 200.0)));
        
        if (glitch > 0.98) {
          uv.x += glitchAmount * (random(vec2(glitchSeed, uv.y)) * 2.0 - 1.0);
          color = texture2D(tDiffuse, uv).rgb;
        }
        
        // Scanlines
        float scanline = sin(uv.y * 800.0 + time * 2.0) * scanlineIntensity + (1.0 - scanlineIntensity);
        color *= scanline;
        
        // Vignette
        float vignette = smoothstep(1.0, 0.7, length(uv - 0.5) * 1.2);
        color *= mix(1.0, vignette, vignetteStrength);
        
        // Subtle blue tint for UI feel
        color = mix(color, color * vec3(0.9, 0.95, 1.1), 0.1);
        
        gl_FragColor = vec4(color, 1.0);
      }
    `
  });
  uiEffectsPass.renderToScreen = true;
  composer.addPass(uiEffectsPass);
  
  // Store for animation
  window.uiEffectsPass = uiEffectsPass;
}

// Create dat.GUI interface
function createGUI() {
  gui = new dat.GUI();
  
  // Effects toggle
  gui.add(settings, 'enableEffects').name('Enable Effects').onChange(function(value) {
    toggleEffects(value);
  });
  
  // Region selector
  gui.add(settings, 'region', Object.keys(regions)).name('US Region').onChange(function(value) {
    updateRegion(value);
  });
  
  // Opacity control - adjust range based on effects mode
  const opacityController = gui.add(settings, 'cubeOpacity', 0.01, 0.3).name('Cube Opacity').onChange(function(value) {
    updateCubeOpacity();
  });
  
  // Store reference for dynamic range updates
  window.opacityController = opacityController;
  
  // Wind randomization button
  gui.add(settings, 'randomizeWind').name('Randomize Wind');
}

// Toggle between enhanced and basic visual modes
function toggleEffects(enabled) {
  if (enabled) {
    // Enable enhanced mode
    scene.background = new THREE.Color(0x0a0a1a); // Dark blue/purple background
    document.body.style.background = 'radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%)';
    
    // Adjust opacity for effects mode
    if (settings.cubeOpacity > 0.15) {
      settings.cubeOpacity = 0.08;
    }
  } else {
    // Enable basic mode
    scene.background = new THREE.Color(0xDBDDEB); // Original light background
    document.body.style.background = ''; // Reset to default
    
    // Adjust opacity for basic mode
    if (settings.cubeOpacity < 0.15) {
      settings.cubeOpacity = 0.03;
    }
  }
  
  // Update opacity controller display
  if (window.opacityController) {
    window.opacityController.updateDisplay();
  }
  
  // Clear existing scene lighting
  const lightsToRemove = [];
  scene.traverse(function(child) {
    if (child instanceof THREE.Light) {
      lightsToRemove.push(child);
    }
  });
  lightsToRemove.forEach(light => scene.remove(light));
  
  // Add appropriate lighting
  if (enabled) {
    // Enhanced lighting for UI feel
    const ambientLight = new THREE.AmbientLight(0x404080, 0.6); // Slightly blue ambient
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0x80a0ff, 0.8); // Cool directional light
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);
  } else {
    // Original basic lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // Bright white ambient light
    scene.add(ambientLight);
  }
  
  // Regenerate cubes with appropriate materials
  regenerateWindData();
}

// Update region and regenerate data
function updateRegion(regionName) {
  settings.region = regionName;
  updateGroundPlane(regions[regionName].mapUrl);
  regenerateWindData();
  updateMiniMap(); // Update mini map when region changes
  updateMiniMapGroundPlane(); // Update mini map ground plane when region changes
}

// Regenerate wind data with current city pattern
function regenerateWindData() {
  // Clear existing cubes
  windCubes.forEach(cube => {
    scene.remove(cube);
  });
  windCubes = [];
  
  // Generate new cubes
  generateWindCubes();
}

// Update ground plane with new map
function updateGroundPlane(mapUrl) {
  if (groundPlane) {
    scene.remove(groundPlane);
  }
  
  const geometry = new THREE.PlaneGeometry(20, 20);
  const textureLoader = new THREE.TextureLoader();
  
  const texture = textureLoader.load(mapUrl, function(loadedTexture) {
    console.log('Map texture loaded for', settings.region);
  }, undefined, function(error) {
    console.error('Failed to load map texture, using fallback', error);
    const material = new THREE.MeshLambertMaterial({ color: 0x4a7c59 });
    groundPlane.material = material;
  });
  
  const material = new THREE.MeshLambertMaterial({ map: texture });
  groundPlane = new THREE.Mesh(geometry, material);
  groundPlane.rotation.x = -Math.PI / 2;
  groundPlane.position.y = -1;
  scene.add(groundPlane);
}

// Create ground plane with real map texture
function createGroundPlane() {
  const currentRegion = regions[settings.region];
  updateGroundPlane(currentRegion.mapUrl);
}

// Generate 10x10x10 wind cube grid with region-specific patterns (10 flight levels)
function generateWindCubes() {
  const windPattern = regions[settings.region].windPattern;
  
  for (let x = -9; x <= 9; x += 2) { // Centered grid from -9 to 9
    for (let y = 0; y < 10; y++) { // 10 flight levels
      for (let z = -9; z <= 9; z += 2) { // Centered grid from -9 to 9
        // Map y levels to standard flight levels FL050-FL500 in increments of 50
        const flightLevel = 50 + (y * 50); // FL050, FL100, FL150, ... FL500
        
        // Generate wind speed based on regional pattern
        let speed = getWindSpeedForPattern(windPattern, x, y * 2, z); // Scale y for pattern
        
        createWindCube(x, y * 2, z, Math.round(speed), flightLevel); // Space cubes 2 units apart vertically
      }
    }
  }
  groupCubesByFlightLevel();
}

// Get wind speed based on region-specific patterns
function getWindSpeedForPattern(pattern, x, y, z) {
  const baseSpeed = 10 + (y * 2.5); // Speed increases with altitude
  let speed = baseSpeed;
  
  switch(pattern) {
    case 'nor_easter':
      // Northeast: Strong easterly flows, coastal influence
      speed += (x + 10) * 1.8 + Math.sin(z * 0.4) * 8 + Math.random() * 18 - 9;
      break;
    case 'gulf_stream':
      // Southeast: Tropical patterns, gulf moisture influence
      const coastalEffect = Math.sin((z + 10) * 0.3) * 12;
      speed += coastalEffect + Math.random() * 16 - 8;
      break;
    case 'continental':
      // Midwest: Variable continental patterns, lake effects
      const lakeEffect = Math.cos(x * 0.6) * Math.sin(z * 0.5) * 15;
      speed += lakeEffect + Math.random() * 22 - 11;
      break;
    case 'desert':
      // Southwest: Thermal updrafts, mountain wave patterns
      const thermalEffect = Math.abs(x) + Math.abs(z);
      speed += thermalEffect * 0.8 + Math.sin(y * 0.4) * 10 + Math.random() * 14 - 7;
      break;
    case 'pacific':
      // Northwest: Strong westerly flow, marine layer influence
      speed += (10 - x) * 2.0 + Math.cos(y * 0.3) * 6 + Math.random() * 16 - 8;
      break;
    case 'plains':
      // Great Plains: Prairie winds, storm system influence
      const stormEffect = Math.sin((x + z) * 0.4) * 12;
      speed += stormEffect + (Math.random() * 25 - 12.5);
      break;
  }
  
  return Math.max(5, Math.min(100, speed));
}

// Create individual wind cube with enhanced or basic material
function createWindCube(x, y, z, speed, flightLevel) {
  const geometry = new THREE.BoxGeometry(2, 2, 2); // Proper 2x2x2 cubes
  
  let material;
  
  if (settings.enableEffects) {
    // Enhanced color mapping with neon colors for UI feel
    let color, emissiveColor;
    if (speed < 20) {
      color = 0x00ff88; // Neon green - calm
      emissiveColor = 0x004422;
    } else if (speed < 35) {
      color = 0x88ff00; // Bright green - light
      emissiveColor = 0x224400;
    } else if (speed < 50) {
      color = 0xffff00; // Neon yellow - moderate
      emissiveColor = 0x444400;
    } else if (speed < 65) {
      color = 0xff8800; // Neon orange - strong
      emissiveColor = 0x442200;
    } else {
      color = 0xff0044; // Neon red - very strong
      emissiveColor = 0x440011;
    }
    
    // Create enhanced material (without glow effects)
    material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        color: { value: new THREE.Color(color) },
        emissiveColor: { value: new THREE.Color(emissiveColor) },
        opacity: { value: settings.cubeOpacity },
        windSpeed: { value: speed / 100.0 } // Normalized wind speed for effects
      },
      vertexShader: `
        uniform float time;
        uniform float windSpeed;
        
        varying vec3 vPosition;
        
        void main() {
          vPosition = position;
          
          // Subtle pulse based on wind speed
          vec3 pos = position;
          float pulse = sin(time * (2.0 + windSpeed * 3.0)) * 0.01 * windSpeed;
          pos += normal * pulse;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 color;
        uniform vec3 emissiveColor;
        uniform float opacity;
        uniform float windSpeed;
        
        varying vec3 vPosition;
        
        void main() {
          // Pulse effect based on wind speed
          float pulse = sin(time * (3.0 + windSpeed * 5.0)) * 0.2 + 0.8;
          
          // Grid pattern for UI feel
          vec2 gridUV = fract(vPosition.xy * 4.0);
          float grid = step(0.9, max(gridUV.x, gridUV.y)) * 0.2;
          
          // Base color with subtle emissive
          vec3 finalColor = color + emissiveColor * pulse * 0.3;
          
          // Add grid highlights
          finalColor += vec3(0.2, 0.4, 1.0) * grid * pulse;
          
          // Wind speed intensity effect
          finalColor *= (0.8 + windSpeed * 0.3);
          
          gl_FragColor = vec4(finalColor, opacity);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide
    });
  } else {
    // Original basic color mapping
    let color;
    if (speed < 20) {
      color = 0x00AA00; // Dark green - calm
    } else if (speed < 35) {
      color = 0x66FF66; // Light green - light
    } else if (speed < 50) {
      color = 0xFFFF00; // Yellow - moderate
    } else if (speed < 65) {
      color = 0xFF8800; // Orange - strong
    } else {
      color = 0xFF0000; // Red - very strong
    }
    
    // Create basic material
    material = new THREE.MeshLambertMaterial({ 
      color: color,
      transparent: true,
      opacity: settings.cubeOpacity
    });
  }
  
  const cube = new THREE.Mesh(geometry, material);
  cube.position.set(x, y, z);
  cube.userData = { 
    speed: speed, 
    flightLevel: flightLevel,
    yLevel: y / 2, // Adjust for hover grouping
    material: settings.enableEffects ? material : null // Store reference for updates only if using effects
  };
  
  scene.add(cube);
  windCubes.push(cube);
}

// Group cubes by flight level
function groupCubesByFlightLevel() {
  const flightLevels = {};
  
  windCubes.forEach(cube => {
    const fl = cube.userData.yLevel; // Group by y level for interaction
    if (!flightLevels[fl]) {
      flightLevels[fl] = [];
    }
    flightLevels[fl].push(cube);
  });
  
  flightLevelGroups = Object.values(flightLevels);
}

// Create flight level labels
function createFlightLevelLabels() {
  // Show labels at each flight level (every 2 y-units = 50 flight level increment)
  for (let y = 0; y < 20; y += 2) {
    const flightLevel = 50 + ((y / 2) * 50);
    const flStr = String(flightLevel).padStart(3, '0');
    createTextSprite(`FL${flStr}`, 11, y, 0);
  }
  
  // Add compass directions on the ground plane
  createCompassLabels();
}

// Create compass direction labels
function createCompassLabels() {
  // N, S, E, W labels around the ground plane edges
  createTextSprite('N', 0, 0, -11);  // North - negative Z (away from viewer)
  createTextSprite('S', 0, 0, 11);   // South - positive Z (toward viewer)
  createTextSprite('E', 11, 0, 0);   // East - positive X
  createTextSprite('W', -11, 0, 0);  // West - negative X
}

// Create text sprite for labels
function createTextSprite(text, x, y, z) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;
  
  context.fillStyle = 'rgba(0, 0, 0, 0.8)';
  context.fillRect(0, 0, canvas.width, canvas.height);
  
  context.fillStyle = 'white';
  context.font = '24px Geist, system-ui, sans-serif';
  context.textAlign = 'center';
  context.fillText(text, canvas.width / 2, 40);
  
  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture });
  const sprite = new THREE.Sprite(material);
  
  sprite.position.set(x, y, z);
  sprite.scale.set(4, 1, 1);
  scene.add(sprite);
}

// Create tooltip element
function createTooltip() {
  tooltip = document.createElement('div');
  tooltip.id = 'tooltip';
  tooltip.style.position = 'absolute';
  tooltip.style.backgroundColor = 'rgba(0, 20, 40, 0.9)';
  tooltip.style.color = '#00ffff';
  tooltip.style.padding = '8px 12px';
  tooltip.style.borderRadius = '6px';
  tooltip.style.fontSize = '14px';
  tooltip.style.fontFamily = 'Geist, system-ui, sans-serif';
  tooltip.style.pointerEvents = 'none';
  tooltip.style.zIndex = '1000';
  tooltip.style.display = 'none';
  tooltip.style.whiteSpace = 'nowrap';
  tooltip.style.border = '1px solid rgba(0, 255, 255, 0.3)';
  tooltip.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.2)';
  tooltip.style.backdropFilter = 'blur(8px)';
  tooltip.style.webkitBackdropFilter = 'blur(8px)';
  document.body.appendChild(tooltip);
}

// Initialize mini map
function initMiniMap() {
  miniMapCanvas = document.getElementById('mini-map-canvas');
  
  // Set up mini map scene
  miniMapScene = new THREE.Scene();
  miniMapScene.background = new THREE.Color(0x001133);
  
  // Set up orthographic camera for top-down view
  miniMapCamera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.1, 100);
  miniMapCamera.position.set(0, 50, 0);
  miniMapCamera.lookAt(0, 0, 0);
  
  // Set up mini map renderer
  miniMapRenderer = new THREE.WebGLRenderer({ canvas: miniMapCanvas, antialias: true });
  miniMapRenderer.setSize(200, 200);
  
  // Add lighting
  const miniMapLight = new THREE.AmbientLight(0xffffff, 1.0);
  miniMapScene.add(miniMapLight);
  
  // Create ground plane for mini map
  const miniMapGeometry = new THREE.PlaneGeometry(20, 20);
  const miniMapTextureLoader = new THREE.TextureLoader();
  
  const currentRegion = regions[settings.region];
  const texture = miniMapTextureLoader.load(currentRegion.mapUrl);
  const miniMapMaterial = new THREE.MeshLambertMaterial({ map: texture });
  miniMapGroundPlane = new THREE.Mesh(miniMapGeometry, miniMapMaterial);
  miniMapGroundPlane.rotation.x = -Math.PI / 2;
  miniMapGroundPlane.position.y = -1;
  miniMapScene.add(miniMapGroundPlane);
}

// Update mini map when flight level is selected
function updateMiniMap() {
  if (!miniMapRenderer) return;
  
  const miniMapCanvasElement = document.getElementById('mini-map-canvas');
  
  if (selectedFlightLevel !== null) {
    // Show mini map
    miniMapCanvasElement.classList.add('visible');
    
    // Clear existing mini map cubes
    miniMapCubes.forEach(cube => {
      miniMapScene.remove(cube);
    });
    miniMapCubes = [];
    
    // Add selected flight level cubes to mini map
    windCubes.forEach(cube => {
      if (cube.userData.yLevel === selectedFlightLevel) {
        const miniCube = cube.clone();
        miniCube.position.copy(cube.position);
        miniCube.position.y = 0; // Flatten to ground level for top view
        miniCube.material = cube.material.clone();
        miniCube.material.opacity = 0.4; // Reduced opacity to see map better
        miniMapScene.add(miniCube);
        miniMapCubes.push(miniCube);
      }
    });
  } else {
    // Hide mini map
    miniMapCanvasElement.classList.remove('visible');
  }
}

// Update mini map ground plane when region changes
function updateMiniMapGroundPlane() {
  if (!miniMapGroundPlane) return;
  
  const currentRegion = regions[settings.region];
  const textureLoader = new THREE.TextureLoader();
  
  const texture = textureLoader.load(currentRegion.mapUrl, function(loadedTexture) {
    miniMapGroundPlane.material.map = loadedTexture;
    miniMapGroundPlane.material.needsUpdate = true;
  });
}

// Handle mouse movement for interactions
function onMouseMove(event) {
  const canvas = renderer.domElement;
  const rect = canvas.getBoundingClientRect();
  
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(windCubes);
  
  if (intersects.length > 0) {
    const hoveredCube = intersects[0].object;
    const hoveredYLevel = hoveredCube.userData.yLevel;
    const flightLevel = hoveredCube.userData.flightLevel;
    const windSpeed = hoveredCube.userData.speed;
    isHovering = true;
    
    // Change cursor to pointer when hovering over cubes
    canvas.style.cursor = 'pointer';
    
    // Show tooltip with flight level info
    tooltip.style.display = 'block';
    tooltip.style.left = (event.clientX + 10) + 'px';
    tooltip.style.top = (event.clientY - 10) + 'px';
    
    // Calculate grid coordinates (convert from world position to grid reference)
    const gridX = Math.round((hoveredCube.position.x + 9) / 2);
    const gridZ = Math.round((hoveredCube.position.z + 9) / 2);
    
    tooltip.innerHTML = `FL${String(flightLevel).padStart(3, '0')}<br/>Wind: ${windSpeed} kt<br/>Grid: ${gridX}, ${gridZ}`;
    
    // Apply hover effects
    windCubes.forEach(cube => {
      let targetOpacity;
      if (cube.userData.yLevel === selectedFlightLevel) {
        // Keep selected level bright
        targetOpacity = 0.5;
      } else if (cube.userData.yLevel === hoveredYLevel) {
        // Highlight hovered level (preview)
        targetOpacity = 0.4;
      } else {
        // Dim other levels using GUI setting
        targetOpacity = settings.cubeOpacity;
      }
      
      // Update opacity based on material type
      if (cube.userData.material && cube.userData.material.uniforms) {
        cube.userData.material.uniforms.opacity.value = targetOpacity;
      } else {
        cube.material.opacity = targetOpacity;
      }
    });
  } else {
    isHovering = false;
    
    // Change cursor to move when not hovering over cubes (orbit mode)
    canvas.style.cursor = 'move';
    
    // Hide tooltip
    tooltip.style.display = 'none';
    
    // Restore selection state or default opacity
    if (selectedFlightLevel !== null) {
      // Restore selection state
      windCubes.forEach(cube => {
        let targetOpacity;
        if (cube.userData.yLevel === selectedFlightLevel) {
          targetOpacity = 0.5; // Keep selected level bright
        } else {
          targetOpacity = settings.cubeOpacity; // Use GUI setting
        }
        
        // Update opacity based on material type
        if (cube.userData.material && cube.userData.material.uniforms) {
          cube.userData.material.uniforms.opacity.value = targetOpacity;
        } else {
          cube.material.opacity = targetOpacity;
        }
      });
    }
    // If no selection, opacity will be handled by distance calculation in animate()
  }
}

// Handle mouse down to track drag start
function onMouseDown(event) {
  mouseDownPosition.x = event.clientX;
  mouseDownPosition.y = event.clientY;
  isDragging = false;
}

// Handle mouse up to detect drag vs click
function onMouseUp(event) {
  const deltaX = Math.abs(event.clientX - mouseDownPosition.x);
  const deltaY = Math.abs(event.clientY - mouseDownPosition.y);
  const dragThreshold = 5; // pixels
  
  isDragging = deltaX > dragThreshold || deltaY > dragThreshold;
}

// Handle mouse clicks for selection
function onMouseClick(event) {
  // Only process click if it wasn't a drag (orbit controls)
  if (isDragging) {
    return;
  }
  
  const canvas = renderer.domElement;
  const rect = canvas.getBoundingClientRect();
  
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(windCubes);
  
  if (intersects.length > 0) {
    const clickedCube = intersects[0].object;
    const clickedYLevel = clickedCube.userData.yLevel;
    
    // If clicking the same level, deselect
    if (selectedFlightLevel === clickedYLevel) {
      deselectFlightLevel();
    } else {
      selectFlightLevel(clickedYLevel);
    }
  }
  // Removed background deselection - only cube clicks affect selection
}

// Touch event handlers for mobile support
function onTouchStart(event) {
  event.preventDefault(); // Prevent default touch behaviors like scrolling
  
  if (event.touches.length === 1) {
    const touch = event.touches[0];
    mouseDownPosition.x = touch.clientX;
    mouseDownPosition.y = touch.clientY;
    isDragging = false;
  }
}

function onTouchMove(event) {
  event.preventDefault(); // Prevent default touch behaviors like scrolling
  
  if (event.touches.length === 1) {
    const touch = event.touches[0];
    const canvas = renderer.domElement;
    const rect = canvas.getBoundingClientRect();
    
    mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
    
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(windCubes);
    
    if (intersects.length > 0) {
      const hoveredCube = intersects[0].object;
      const hoveredYLevel = hoveredCube.userData.yLevel;
      const flightLevel = hoveredCube.userData.flightLevel;
      const windSpeed = hoveredCube.userData.speed;
      isHovering = true;
      
      // Show tooltip with flight level info
      tooltip.style.display = 'block';
      tooltip.style.left = (touch.clientX + 10) + 'px';
      tooltip.style.top = (touch.clientY - 10) + 'px';
      
      // Calculate grid coordinates (convert from world position to grid reference)
      const gridX = Math.round((hoveredCube.position.x + 9) / 2);
      const gridZ = Math.round((hoveredCube.position.z + 9) / 2);
      
      tooltip.innerHTML = `FL${String(flightLevel).padStart(3, '0')}<br/>Wind: ${windSpeed} kt<br/>Grid: ${gridX}, ${gridZ}`;
      
      // Apply hover effects
      windCubes.forEach(cube => {
        let targetOpacity;
        if (cube.userData.yLevel === selectedFlightLevel) {
          // Keep selected level bright
          targetOpacity = 0.5;
        } else if (cube.userData.yLevel === hoveredYLevel) {
          // Highlight hovered level (preview)
          targetOpacity = 0.4;
        } else {
          // Dim other levels using GUI setting
          targetOpacity = settings.cubeOpacity;
        }
        
        // Update opacity based on material type
        if (cube.userData.material && cube.userData.material.uniforms) {
          cube.userData.material.uniforms.opacity.value = targetOpacity;
        } else {
          cube.material.opacity = targetOpacity;
        }
      });
    } else {
      isHovering = false;
      
      // Hide tooltip
      tooltip.style.display = 'none';
      
      // Restore selection state or default opacity
      if (selectedFlightLevel !== null) {
        // Restore selection state
        windCubes.forEach(cube => {
          let targetOpacity;
          if (cube.userData.yLevel === selectedFlightLevel) {
            targetOpacity = 0.5; // Keep selected level bright
          } else {
            targetOpacity = settings.cubeOpacity; // Use GUI setting
          }
          
          // Update opacity based on material type
          if (cube.userData.material && cube.userData.material.uniforms) {
            cube.userData.material.uniforms.opacity.value = targetOpacity;
          } else {
            cube.material.opacity = targetOpacity;
          }
        });
      }
    }
  }
}

function onTouchEnd(event) {
  event.preventDefault(); // Prevent default touch behaviors like scrolling
  
  if (event.changedTouches.length === 1) {
    const touch = event.changedTouches[0];
    const deltaX = Math.abs(touch.clientX - mouseDownPosition.x);
    const deltaY = Math.abs(touch.clientY - mouseDownPosition.y);
    const dragThreshold = 5; // pixels
    
    isDragging = deltaX > dragThreshold || deltaY > dragThreshold;
    
    // Only process tap if it wasn't a drag (orbit controls)
    if (!isDragging) {
      const canvas = renderer.domElement;
      const rect = canvas.getBoundingClientRect();
      
      mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(windCubes);
      
      if (intersects.length > 0) {
        const tappedCube = intersects[0].object;
        const tappedYLevel = tappedCube.userData.yLevel;
        
        // If tapping the same level, deselect
        if (selectedFlightLevel === tappedYLevel) {
          deselectFlightLevel();
        } else {
          selectFlightLevel(tappedYLevel);
        }
      }
    }
    
    // Always hide tooltip when touch ends
    tooltip.style.display = 'none';
    isHovering = false;
    
    // Restore proper opacity state
    if (selectedFlightLevel !== null) {
      windCubes.forEach(cube => {
        let targetOpacity;
        if (cube.userData.yLevel === selectedFlightLevel) {
          targetOpacity = 0.5;
        } else {
          targetOpacity = settings.cubeOpacity;
        }
        
        // Update opacity based on material type
        if (cube.userData.material && cube.userData.material.uniforms) {
          cube.userData.material.uniforms.opacity.value = targetOpacity;
        } else {
          cube.material.opacity = targetOpacity;
        }
      });
    }
  }
}

// Select a flight level
function selectFlightLevel(yLevel) {
  // Clear previous selection
  deselectFlightLevel();
  
  selectedFlightLevel = yLevel;
  
  // Add white wireframes to selected cubes and set opacity
  windCubes.forEach(cube => {
    if (cube.userData.yLevel === yLevel) {
      // Highlight selected level
      if (cube.userData.material && cube.userData.material.uniforms) {
        cube.userData.material.uniforms.opacity.value = 0.5;
      } else {
        cube.material.opacity = 0.5;
      }
      
      // Add wireframe outline based on effects setting
      const wireframeGeometry = new THREE.BoxGeometry(2, 2, 2);
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: settings.enableEffects ? 0x00ffff : 0xffffff, // Cyan for effects, white for basic
        wireframe: true,
        transparent: true,
        opacity: 0.8
      });
      const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
      wireframe.position.copy(cube.position);
      scene.add(wireframe);
      selectedCubes.push(wireframe);
    } else {
      // Use GUI setting for dimmed levels
      if (cube.userData.material && cube.userData.material.uniforms) {
        cube.userData.material.uniforms.opacity.value = settings.cubeOpacity;
      } else {
        cube.material.opacity = settings.cubeOpacity;
      }
    }
  });
  updateMiniMap(); // Update mini map when flight level is selected
}

// Deselect current flight level
function deselectFlightLevel() {
  selectedFlightLevel = null;
  
  // Remove all wireframes
  selectedCubes.forEach(wireframe => {
    scene.remove(wireframe);
  });
  selectedCubes = [];
  
  // Reset all cube opacities to default
  windCubes.forEach(cube => {
    if (cube.userData.material && cube.userData.material.uniforms) {
      cube.userData.material.uniforms.opacity.value = settings.cubeOpacity;
    } else {
      cube.material.opacity = settings.cubeOpacity;
    }
  });
  updateMiniMap(); // Update mini map when flight level is deselected
}

// Handle window resize
function onWindowResize() {
  const canvas = renderer.domElement;
  const rect = canvas.getBoundingClientRect();
  
  camera.aspect = rect.width / rect.height;
  camera.updateProjectionMatrix();
  renderer.setSize(rect.width, rect.height);
  
  // Only resize composer when effects are enabled
  if (settings.enableEffects && composer) {
    composer.setSize(rect.width, rect.height);
  }
}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  // Update controls
  controls.update();
  
  // Update time for post-processing effects (only when effects are enabled)
  if (settings.enableEffects) {
    time = clock.getElapsedTime();
    if (window.uiEffectsPass) {
      window.uiEffectsPass.uniforms.time.value = time;
    }

    // Update cube materials with time and effects
    windCubes.forEach(cube => {
      if (cube.userData.material && cube.userData.material.uniforms) {
        // Update time uniform for animation
        cube.userData.material.uniforms.time.value = time;
      }
    });
  }

  // Update cube opacity based on camera distance only when not hovering and not selected
  if (!isHovering && selectedFlightLevel === null) {
    const cameraPosition = camera.position;
    windCubes.forEach(cube => {
      const distance = cameraPosition.distanceTo(cube.position);
      const opacity = Math.max(0.02, Math.min(settings.cubeOpacity, (80 - distance) / 80)); // Use GUI setting as max
      
      // Update shader material opacity
      if (cube.userData.material && cube.userData.material.uniforms) {
        cube.userData.material.uniforms.opacity.value = opacity;
      } else {
        cube.material.opacity = opacity;
      }
    });
  }
  
  // Render main scene - use composer with effects or basic renderer
  if (settings.enableEffects) {
    composer.render(); // Render through composer with post-processing
  } else {
    renderer.render(scene, camera); // Basic rendering without effects
  }
  
  // Render mini map if visible
  if (miniMapRenderer && selectedFlightLevel !== null) {
    miniMapRenderer.render(miniMapScene, miniMapCamera);
  }
}

// Update cube opacity based on GUI setting
function updateCubeOpacity() {
  // Only update if no specific hover/selection state is active
  if (!isHovering && selectedFlightLevel === null) {
    windCubes.forEach(cube => {
      if (cube.userData.material && cube.userData.material.uniforms) {
        cube.userData.material.uniforms.opacity.value = settings.cubeOpacity;
      } else {
        cube.material.opacity = settings.cubeOpacity;
      }
    });
  } else if (selectedFlightLevel !== null) {
    // Update dimmed cubes in selection state
    windCubes.forEach(cube => {
      if (cube.userData.yLevel !== selectedFlightLevel) {
        if (cube.userData.material && cube.userData.material.uniforms) {
          cube.userData.material.uniforms.opacity.value = settings.cubeOpacity;
        } else {
          cube.material.opacity = settings.cubeOpacity;
        }
      }
    });
  }
}

// Start the visualization
initScene();
animate(); 
</script>